from git import Repo
import argparse
import contextlib
import logging
import math
import multiprocessing
import os
import pathlib
import requests
import subprocess


ROCM_VERSION = '2.4.0'
# Most ROCm repos have a branch per major release
ROCM_VERSION_BRANCH = 'roc-2.4.x'
ROCM_TAG = 'roc-{}'.format(ROCM_VERSION)

# I kept most the names of these variables as similar as possible as the ones in the ROCm installation scripts

# JCC: for the moment, I leave this path like this. I have created the /opt/rocm folder and obmun user is the owner.
ROCM_OUTPUT_DIR_P = pathlib.Path('/opt/rocm')
ROCM_OUTPUT_DIR_STR = ROCM_OUTPUT_DIR_P.as_posix()
ROCM_OUTPUT_LIB64_DIR_P = ROCM_OUTPUT_DIR_P / 'lib64'
ROCM_OUTPUT_OPENCL_DIR_P = ROCM_OUTPUT_DIR_P / 'opencl'
ROCM_OUTPUT_OPENCL_LIB_DIR_P = ROCM_OUTPUT_OPENCL_DIR_P / 'lib'
ROCM_OUTPUT_OPENCL_LIB_DIR_STR = ROCM_OUTPUT_OPENCL_LIB_DIR_P.as_posix()

# TODO: understand what is what they call the INPUT_DIR!
#  * It looks like they consider this path as a path with potential "input files"
#  * They populate it as they install components that are dependencies for later components.
#  * Examples of what they call "input files"
#     - Headers generated by other components
#     - Compilers/other tools generated in previous steps
ROCM_INPUT_DIR_P = pathlib.Path('/opt/rocm')

ROCM_ROCT_REPO_URL = 'https://github.com/RadeonOpenCompute/ROCT-Thunk-Interface.git'
ROCM_ROCR_REPO_URL = 'https://github.com/RadeonOpenCompute/ROCR-Runtime.git'
OPENCL_RUNTIME_URL = 'https://github.com/RadeonOpenCompute/ROCm-OpenCL-Runtime.git'

ROCM_CMAKE_BUILD_TYPE = 'Release'
ROCM_CPACK_RPM_PERMISSIONS =\
    '-DCPACK_RPM_DEFAULT_DIR_PERMISSIONS="OWNER_READ;OWNER_WRITE;OWNER_EXECUTE;GROUP_READ;GROUP_EXECUTE;WORLD_READ' \
    ';WORLD_EXECUTE" '

OPENCL_VENDORS_DIR_P = pathlib.Path('/etc/OpenCL/vendors')

use_packages = False


@contextlib.contextmanager
def working_dir(path):
    """Changes working directory and returns to previous on exit."""
    prev_cwd = pathlib.Path.cwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(prev_cwd)


def build_cmake_defines_args(defines_map):
    defines_str = ''
    for define, value in defines_map.items():
        if defines_str:
            defines_str += ' '
        defines_str += '-D{}={}'.format(define, value)
    return defines_str


def mem_size():
    """Retrieves the system physical memory size, in GiB"""
    mem_bytes = os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')
    return mem_bytes / (1024. ** 3)


def clone_component_repo(friendly_name, srcs_dir_p, subfolder_name, repo_url, tag):
    '''

    :param friendly_name: a friendly name for this sources, to use in messages to the user. E.g: 'ROCr'
    :param srcs_dir_p:  The `sources/` dir path
    :param tag: The git tag to checkout
    :return: The path where the component repo has been checked-out
    '''

    comp_srcs_dir_p = srcs_dir_p / subfolder_name
    if not comp_srcs_dir_p.exists():
        logging.info('Preparing (git cloning) {} sources'.format(friendly_name))

        comp_srcs_dir_p.mkdir()

        repo = Repo.clone_from(repo_url, str(comp_srcs_dir_p))
        repo.git.checkout(tag)
        # patch -p1 < ${BASE_DIR}/patches/01_02_rocr.patch
        # cd ${SOURCE_DIR}/ROCR-Runtime/src
    else:
        logging.info('{} source folder already exists. ASSUMING sources have been already successfully prepared'.format(friendly_name))
        logging.warning('Skipping ROCr sources download step')

    return comp_srcs_dir_p


parser = argparse.ArgumentParser(description="ROCm installer script")
parser.add_argument('--skip_requirements', help='Skips installation of any DNF/pip requirements', action='store_true')
parser.add_argument('--skip_build', help='Skips build steps in any of the components', action='store_true')
parser.set_defaults(skip_requirements=True)
parser.set_defaults(skip_build=True)
args = parser.parse_args()

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler('rocm_install.log')
fh.setLevel(logging.DEBUG)
# Console handler, only with info level
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
logger.addHandler(fh)
logger.addHandler(ch)

n_proc = multiprocessing.cpu_count()

sudo_cmds_log = []

# 1. Make sure system is up to date
#dnf update
# Build requirements
if not args.skip_requirements:
    print('Installing build dependencies:')
    proc = subprocess.Popen(['sudo dnf install -y git cmake pkgconf-pkg-config pciutils pciutils-devel'],
                            stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
    res = proc.wait()
    assert res == 0

# On Fedora, we can skip the kernel module because the proper KFD version was backported so our user-land tools can
# work cleanly.
#${BASE_DIR}/component_scripts/01_00_rock-dkms.sh "$@"


srcs_p = pathlib.Path("./sources").resolve()
srcs_p.mkdir(exist_ok=True)

srcs_bin_p = srcs_p / 'bin'
assert srcs_bin_p.is_absolute()
srcs_bin_p.mkdir(exist_ok=True)


print('==== ROCt Thunk layer ====')

# The ROCt thunk layer is the user-mode API interfaces used to interact with the ROCk driver

roct_sources_dir_p = clone_component_repo(
    friendly_name='ROCt', srcs_dir_p=srcs_p, subfolder_name='ROCT-Thunk-Interface',
    repo_url=ROCM_ROCT_REPO_URL, tag=ROCM_TAG)

roct_build_dir_p = roct_sources_dir_p / 'build'
roct_build_dir_p.mkdir(exist_ok=True)
with working_dir(roct_build_dir_p):
    cmake_defines = {
        'CMAKE_BUILD_TYPE': ROCM_CMAKE_BUILD_TYPE,
        'CMAKE_INSTALL_PREFIX': ROCM_OUTPUT_DIR_P.as_posix(),
        'CPACK_PACKAGING_INSTALL_PREFIX': ROCM_OUTPUT_DIR_P.as_posix(),
        'CPACK_GENERATOR': 'RPM'
    }
    defines_str = build_cmake_defines_args(cmake_defines)
    defines_str += ' ' + ROCM_CPACK_RPM_PERMISSIONS
    cmdline = 'cmake {} ..'.format(defines_str)

    proc = subprocess.Popen(cmdline, shell=True)
    res = proc.wait()
    assert res == 0

    cmdlines = [
        'make -j {}'.format(n_proc),
        'make -j {} build-dev'.format(n_proc)
    ]
    for cmdline in cmdlines:
        proc = subprocess.Popen(cmdline, shell=True)
        res = proc.wait()
        assert res == 0

    if use_packages:
        logging.info('Preparing and installing ROCt RPM packages ')

        raise NotImplemented()

        # make package
        # echo "Copying `ls -1 hsakmt-roct-*.rpm` to ${ROCM_PACKAGE_DIR}"
        # mkdir -p ${ROCM_PACKAGE_DIR}
        # cp hsakmt-roct-*.rpm ${ROCM_PACKAGE_DIR}
        # if [ ${ROCM_LOCAL_INSTALL} = false ]; then
        #     ROCM_PKG_IS_INSTALLED=`rpm -qa | grep hsakmt-roct-[0-9] | wc -l`
        #     if [ ${ROCM_PKG_IS_INSTALLED} -gt 0 ]; then
        #         PKG_NAME=`rpm -qa | grep hsakmt-roct-[0-9] | head -n 1`
        #         sudo rpm -e --nodeps ${PKG_NAME}
        #     fi
        #     sudo rpm -i hsakmt-roct-*.rpm
        # fi
        # cd hsakmt-roct-dev
        # make package
        # echo "Copying `ls -1 hsakmt-roct-dev-*.rpm` to ${ROCM_PACKAGE_DIR}"
        # cp hsakmt-roct-dev-*.rpm ${ROCM_PACKAGE_DIR}
        # ROCM_PKG_IS_INSTALLED=`rpm -qa | grep hsakmt-roct-dev | wc -l`
        # if [ ${ROCM_LOCAL_INSTALL} = false ]; then
        #     ROCM_PKG_IS_INSTALLED=`rpm -qa | grep hsakmt-roct-dev | wc -l`
        #     if [ ${ROCM_PKG_IS_INSTALLED} -gt 0 ]; then
        #         PKG_NAME=`rpm -qa | grep hsakmt-roct-dev | head -n 1`
        #         sudo rpm -e --nodeps ${PKG_NAME}
        #     fi
        #     sudo rpm -i hsakmt-roct-dev-*.rpm
        # fi
    else:
        logging.info('Installing ROCt ')

        ROCM_OUTPUT_LIB64_DIR_P.mkdir(exist_ok=True)

        cmdlines = ['make install', 'make install-dev']
        for cmdline in cmdlines:
            proc = subprocess.Popen(cmdline, shell=True)
            res = proc.wait()
            assert res == 0

        # if [ ${ROCM_LOCAL_INSTALL} = false ]; then
        #     ${ROCM_SUDO_COMMAND} sh -c "echo ${ROCM_OUTPUT_DIR}/lib > /etc/ld.so.conf.d/x86_64-libhsakmt.conf"
        #     ${ROCM_SUDO_COMMAND} sh -c "echo ${ROCM_OUTPUT_DIR}/lib64 > /etc/ld.so.conf.d/x86_64-libhsakmt.conf"
        #     ${ROCM_SUDO_COMMAND} ldconfig
        # fi


print('==== ROCr runtime ====')

# The ROCr runtime is the HSA Runtime API and runtime for ROCm.
# These are the user-mode API interfaces and libraries necessary for host applications to launch compute kernels to
# available HSA ROCm kernel agents.
#
# Dependencies:
# 1. ROCt library

if not args.skip_requirements:
    logging.info('Installing ROCr build prerequisites')
    # TODO: extract common ones
    proc = subprocess.Popen('sudo dnf -y install cmake pkgconf-pkg-config git make gcc-c++ elfutils-libelf '
                            'elfutils-libelf-devel rpm-build',
                            shell=True)
    res = proc.wait()
    assert res == 0

rocr_sources_dir_p = clone_component_repo(
    friendly_name='ROCr', srcs_dir_p=srcs_p, subfolder_name='ROCR-Runtime',
    repo_url=ROCM_ROCR_REPO_URL, tag=ROCM_TAG)

rocr_build_dir_p = rocr_sources_dir_p / 'src' / 'build'
rocr_build_dir_p.mkdir(exist_ok=True)
with working_dir(rocr_build_dir_p):
    cmake_defines = {
        'CMAKE_BUILD_TYPE': ROCM_CMAKE_BUILD_TYPE,
        'CMAKE_INSTALL_PREFIX': ROCM_OUTPUT_DIR_P.as_posix(),
        'CMAKE_LIBRARY_PATH': (ROCM_INPUT_DIR_P / 'lib').as_posix(),
        # TODO: TEMP_INCLUDE_DIR thing1
        'CMAKE_INCLUDE_PATH': (ROCM_INPUT_DIR_P / 'include').as_posix(),
        'CPACK_PACKAGING_INSTALL_PREFIX': ROCM_OUTPUT_DIR_P.as_posix(),
        'CPACK_GENERATOR': 'RPM'
    }
    # JCC note: why does the CMAKE_INCLUDE_PATH define work for the ROCt includes that are installed into /opt/rocm from
    # previous components?
    #
    # Remember: the CMAKE_INCLUDE_PATH only sets paths to be used by CMAKE in the find_file() and a few other cmds
    #
    # This assists them in finding the includes because ... precisly they are doping a find_file('roct_header.h').
    # Thru the CMAKE_INCLUDE_PATH hint in cmake cmdline, they'll locate this.
    defines_str = build_cmake_defines_args(cmake_defines)
    defines_str += ' ' + ROCM_CPACK_RPM_PERMISSIONS
    cmdline = 'cmake {} ..'.format(defines_str)
    print(cmdline)

    proc = subprocess.Popen(cmdline, shell=True)
    res = proc.wait()
    assert res == 0

    cmdline = 'make -j {}'.format(n_proc)
    proc = subprocess.Popen(cmdline, shell=True)
    res = proc.wait()
    assert res == 0

    if use_packages:
        logging.info('Preparing and installing ROCr RPM packages ')

        raise NotImplemented()
    else:
        logging.info('Installing ROCr')

        ROCM_OUTPUT_LIB64_DIR_P.mkdir(exist_ok=True)

        proc = subprocess.Popen('make install', shell=True)
        res = proc.wait()
        assert res == 0

        # if [ ${ROCM_LOCAL_INSTALL} = false ]; then
        #     ${ROCM_SUDO_COMMAND} sh -c "echo ${ROCM_OUTPUT_DIR}/hsa/lib > /etc/ld.so.conf.d/hsa-rocr-dev.conf"
        #     ${ROCM_SUDO_COMMAND} ldconfig
        # fi


print('==== ROCm OpenCL runtime ====')

# Dependencies:
# 1. ROCr (the ROCm runtime)

if not args.skip_requirements:
    print('Installing build prerequisites')
    proc = subprocess.Popen('sudo dnf -y install git make ocaml ocaml-findlib git-svn curl mesa-libGL-devel cmake '
                            'gcc-c++ rpm-build',
                            shell=True)
    res = proc.wait()
    assert res == 0
    proc = subprocess.Popen('sudo dnf -y install python-pip', shell=True)
    res = proc.wait()
    assert res == 0
    proc = subprocess.Popen('sudo pip install z3-solver', shell=True)
    res = proc.wait()
    assert res == 0

    # Fedora 30 includes GTest 1.8.1, which is what they seem to be requiring as a minimum
    proc = subprocess.Popen('sudo dnf -y install gtest-devel', shell=True)
    res = proc.wait()
    assert res == 0

# == Get repo tool ==
# Unconditionally, it is small enough
response = requests.get('https://storage.googleapis.com/git-repo-downloads/repo')
repo_script_p = srcs_bin_p / 'repo'
assert repo_script_p.is_absolute()
# Patch repo script
#     Repo script has a shebang that looks like this:
#         /usr/bin/env python
#     In the normal Fedora user env, python will map to Python2
#     BUT, under a PyCharm pipenv console, due to PATH priorities, this will POINT to Python 3, which is NOT fully
#     supported by the REPO script.
#     Solution: make _explicit_ use of Python2 in the shebang.
repo_tool_contents = response.content
shebang_template = '/usr/bin/env {}'
shebang_bytes = shebang_template.format('python').encode('UTF-8')
idx = repo_tool_contents.find(shebang_bytes)
assert idx < repo_tool_contents.find('\n'.encode('UTF-8'))
repo_tool_contents = repo_tool_contents.replace(shebang_bytes, shebang_template.format('python2').encode('UTF-8'), 1)

with repo_script_p.open("wb") as f:
    f.write(repo_tool_contents)
repo_script_p.chmod(0o755)

# == Get ROCm OpenCL source code ==
# This is huge. Avoid if the OpenCL sources folder is there.

opencl_runtime_sources_dir_p = srcs_p / 'OCL'
if not opencl_runtime_sources_dir_p.exists():
    opencl_runtime_sources_dir_p.mkdir()
    # if opencl_runtime_sources_dir_p.exists():
    #     repo = Repo(str(opencl_runtime_sources_dir_p))
    # else:
    #     repo = Repo.clone_from(OPENCL_RUNTIME_URL, str(opencl_runtime_sources_dir_p))
    # tag_ref = repo.tags[ROCM_TAG]
    # repo.git.checkout(ROCM_TAG)

    with working_dir(opencl_runtime_sources_dir_p):
        cmdline = '{repo_tool} init -u {repo_url} -b {branch} -m opencl.xml'.format(
            repo_tool=repo_script_p.as_posix(), repo_url=OPENCL_RUNTIME_URL, branch=ROCM_VERSION_BRANCH)
        print(cmdline)
        proc = subprocess.Popen(cmdline, shell=True)
        res = proc.wait()
        assert res == 0

        cmdline = '{repo_tool} sync'.format(repo_tool=repo_script_p.as_posix())
        print(cmdline)
        proc = subprocess.Popen(cmdline, shell=True)
        res = proc.wait()
        assert res == 0

else:
    logging.info('OpenCL source folder already exists. ASSUMING sources have been already successfully downloaded.')
    logging.warning('Skipping ROCm OpenCL sources download step')

opencl_runtime_checkout_dir_p = opencl_runtime_sources_dir_p / 'opencl'
# Create build folder inside the checkout
opencl_build_dir_p = opencl_runtime_checkout_dir_p / 'build'
opencl_build_dir_p.mkdir(exist_ok=True)

# Give about 4 GB min to each building thread
mem_limited_jobs_count = math.floor(mem_size() / 4)
n_concurrent_jobs = min(n_proc, mem_limited_jobs_count)
n_concurrent_jobs = max(n_concurrent_jobs, 1)

with working_dir(opencl_build_dir_p):
    if not args.skip_build:
        cmake_defines = {
            'CMAKE_BUILD_TYPE': ROCM_CMAKE_BUILD_TYPE,
            'CMAKE_INSTALL_PREFIX': (ROCM_OUTPUT_DIR_P / 'opencl').as_posix(),
            'LLVM_USE_LINKER': 'gold',
            'CMAKE_LIBRARY_PATH': (ROCM_INPUT_DIR_P / 'lib').as_posix(),
            'CMAKE_INCLUDE_PATH': (ROCM_INPUT_DIR_P / 'include').as_posix(),
            'CLANG_ANALYZER_ENABLE_Z3_SOLVER': 'OFF',
            'CPACK_PACKAGING_INSTALL_PREFIX': ROCM_OUTPUT_DIR_P.as_posix(),
            'CPACK_GENERATOR': 'RPM'
        }
        defines_str = build_cmake_defines_args(cmake_defines)
        defines_str += ' ' + ROCM_CPACK_RPM_PERMISSIONS
        cmdline = 'cmake {} ..'.format(defines_str)
        logging.debug(cmdline)

        proc = subprocess.Popen(cmdline, shell=True)
        res = proc.wait()
        assert res == 0

        proc = subprocess.Popen('make -j {}'.format(n_concurrent_jobs), shell=True)
        res = proc.wait()
        assert res == 0
    else:
        logging.info('(user requested) Skipping OpenCl build step')

    if use_packages:
        logging.info('Preparing and installing ROCm OpenCL RPM packages ')

        raise NotImplemented()
    else:
        logging.info('Installing ROCm OpenCL')

        # proc = subprocess.Popen('make install', shell=True)
        # res = proc.wait()
        # assert res == 0

        cmdlines = []
        cmdlines += ['sudo mkdir -p /']
        amdocl64_icd_p = opencl_runtime_checkout_dir_p / 'api/opencl/config/amdocl64.icd'
        print(amdocl64_icd_p)
        assert amdocl64_icd_p.exists()
        cmdlines += ['sudo cp {src} {dest_dir}'.format(src=amdocl64_icd_p.as_posix(), dest_dir=OPENCL_VENDORS_DIR_P.as_posix())]
        cmdlines += [
            """echo 'export PATH=$PATH:'"${rocm_out_dir}/bin:${rocm_out_dir}/profiler/bin:${rocm_out_dir}/opencl/bin/x86_64" | sudo tee -a /etc/profile.d/rocm.sh""".format(
                rocm_out_dir=ROCM_OUTPUT_DIR_P.as_posix()
            )
        ]
        sudo_cmds_log += cmdlines
        for cmdline in cmdlines:
            proc = subprocess.Popen(cmdline, shell=True)
            res = proc.wait()
            assert res == 0

        cmdlines = []

        # --- Fix up OpenCL installation locations :( ---
        # Should have this in ${ROCM_OUTPUT_DIR}/opencl/lib/x86_64/:
        #     bitcode  libamdocl64.so  libcltrace.so  libOpenCL.so  libOpenCL.so.1

        # This installation paths seemed to be broken in the install cmds on ROCm-2.0.0. For 2.4.0 the correction is NOT
        # needed, as they are in the correct places; correct means "as indicated by the ROCm installation scripts"
        #cmdlines += [f'mkdir -p {ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/x86_64/bitcode/']
        #cmdlines += [f'cp {ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/*.bc {ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/x86_64/bitcode/']
        #cmdlines += [f'cp {ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/libOpenCL.so.1.2 ${ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/x86_64/']
        # But this simlink is still missing:
        cmdlines += [f'sh -c "cd {ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/x86_64; ln -sf libOpenCL.so.1.2 libOpenCL.so.1"']
        #${ROCM_SUDO_COMMAND} ln -sf ${ROCM_OUTPUT_DIR}/opencl/lib/x86_64/libOpenCL.so.1 ${ROCM_OUTPUT_DIR}/opencl/lib/x86_64/libOpenCL.so
        #${ROCM_SUDO_COMMAND} cp ${ROCM_OUTPUT_DIR}/opencl/lib/libamdocl64.so ${ROCM_OUTPUT_DIR}/opencl/lib/x86_64/
        # Nothing to delete as well in the lib folder. lib/lib* does not exist, and no clang/ subfolder
        #${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/lib/lib*
        #${ROCM_SUDO_COMMAND} rm -rf ${ROCM_OUTPUT_DIR}/opencl/lib/clang/

        # --- ld.so config ---
        cmdlines += [f'sh -c \'echo "{ROCM_OUTPUT_OPENCL_LIB_DIR_STR}/x86_64" >>/etc/ld.so.conf.d/x86_64-rocm-opencl.conf\'']
        cmdlines += ['ldconfig']

        for idx, cmdline in enumerate(cmdlines):
            cmdline = 'sudo ' + cmdline
            cmdlines[idx] = cmdline
            print(cmdline)
            proc = subprocess.Popen(cmdline, shell=True)
            res = proc.wait()
            assert res == 0
        sudo_cmds_log += cmdlines

        #
        # # $ ls /opt/rocm/opencl/bin/x86_64/
        # # clang  clinfo  ld.lld  llc  llvm-link  llvm-objdump  opt
        #
        # ${ROCM_SUDO_COMMAND} mkdir -p ${ROCM_OUTPUT_DIR}/opencl/bin/x86_64/
        # # missing llc, llvm-link, llvm-objdump opt, but these are not
        # # needed for libOpenCL.so operation
        # for i in clang clang-[0-9] clinfo ld.lld lld; do ${ROCM_SUDO_COMMAND} cp ${ROCM_OUTPUT_DIR}/opencl/bin/$i ${ROCM_OUTPUT_DIR}/opencl/bin/x86_64/; done
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/clang*
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/git-clang-format
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/ld64.lld
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/lld-link
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/roc-cl
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/bin/wasm-ld
        #
        # # $ ls /opt/rocm/opencl/include/
        # # CL  opencl-c.h
        # #$ ls /opt/rocm/opencl/include/CL/
        # #cl_ext.h  cl_gl_ext.h  cl_gl.h  cl.h  cl.hpp  cl_platform.h  opencl.h
        # ${ROCM_SUDO_COMMAND} cp -R ${ROCM_OUTPUT_DIR}/opencl/include/opencl2.2/ /tmp/
        # ${ROCM_SUDO_COMMAND} rm -rf ${ROCM_OUTPUT_DIR}/opencl/include/*
        # ${ROCM_SUDO_COMMAND} mkdir -p ${ROCM_OUTPUT_DIR}/opencl/include/CL/
        # ${ROCM_SUDO_COMMAND} cp -R /tmp/opencl2.2/CL/ ${ROCM_OUTPUT_DIR}/opencl/include/
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/include/CL/cl_d3d*
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/include/CL/cl_dx9*
        # ${ROCM_SUDO_COMMAND} rm -f ${ROCM_OUTPUT_DIR}/opencl/include/CL/cl2.hpp
        # ${ROCM_SUDO_COMMAND} rm -rf /tmp/opencl2.2/

# BINARY-ONLY OpenCL (as HSA elements) TO DOWNLOAD:
# * http://repo.radeon.com/rocm/yum/rpm
#   * Particularly, we need: http://repo.radeon.com/rocm/yum/rpm/hsa-ext-rocr-dev-1.1.9-74-g4eea4a1c-Linux.rpm